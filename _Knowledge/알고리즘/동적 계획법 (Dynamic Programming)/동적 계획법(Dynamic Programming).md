

## 동적 계획법 (DP)

- 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법

## 동적 계획법 원리 & 구현 방식
1. 큰 문제를 작은 문제로 나눌 수 있어야 함    
2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결과값은 항상 같아야함  
3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 이 DP 테이블을 이용 -> `메모제이션 기법`
4. 동적 계획법은 `톱-다운(top-down) 방식` 과 `바텀-업(bottom-up) 방식` 으로 구현할 수 있음



## 피보나치 수열

<img src="https://images.velog.io/images/southbig89/post/c491ec81-09a2-47c8-a810-54e85f19d2dc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.14.12.png" width="300">

> 💡피보나치 수열  
> - N번째 피보나치 수열은 N-1번째 수열과 N-2번째 수열의 합  
> - 즉 6번째 피보나치 수열은 5번째 수열과 4번째 수열의 합  
>
> 💡피보나치 수열 공식
> **D[N] = D[N-1] + D[N-2]**

- N번째 피보나치 수열을 구하는 방법은 N-1 번째 수열, N-2번째 수열을 구하는 작은 문제로 나눌 수 있고 수열의 값은 항상 같기 때문에 동적 계획법으로 풀 수 있음

## 동적 계획법 구현 방식
1. 동적 계획법으로 풀 수 있는지 확인
2. 점화식 세우기
3. 메모이제이션 원리 이해
	- `메모이제이션`은 부분 문제를 풀었을 때 이 문제를 DP테이블에 저장하고 다음에 같은 문제를 풀 때 재계산하지 않고 저장한 DP테이블의 값을 이용하는 것
4. 톱-다운 구현 방식 이해
	- 위에서부터 문제를 파악해 내려오는 방식
	- 재귀 함수 형태로 코드 구현
	- 코드 가독성 좋고 이해하기 편함
5. 바텀-업 구현 방식 이해
	- 가장 작은 부분 문제부터 문제를 해결하면서 점점 큰 문제로 확장해 나가는 방식
	- 반복문의 형태로 구현


### 톱- 다운 방식 피보나치 수열  

```java
public class Main {  
    static int[] D;  
    public static void main(String[] args) {  
        int n = 6;  
        D = new int[n+1];  
        for (int i = 0; i <= n; i++) {  
            D[i] = -1;  
        }  
        D[0]= 0;  
        D[1]=1;  
        fibo(n);  
        System.out.println(D[n]);  
    }  
  
    static int fibo(int n){  
        if (D[n] != -1)  
            return D[n];  
        return D[n] = fibo(n-2) + fibo(n-1);  
    }  
}
```

### 바텀-업 방식 피보나치 수열  
```java
public class Main {  
  
    static int[] D;  
    public static void main(String[] args) {  
        int n = 6;  
        D = new int [n+1];  
        for(int i=0;i<=n;i++){  
            D[i] = -1;  
        }  
  
        D[0] = 0;  
        D[1] = 1;  
  
        for(int i=2;i<=n;i++){  
            D[i] = D[i-1] + D[i-2];  
        }  
        System.out.println(D[n]);  
    }  
}
```



